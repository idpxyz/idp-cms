下面是一套**Channel + Tag + Article 的一体化落地方案**，面向 **Wagtail 7.1** 的大型多站点新闻平台（Portal + 地方站），覆盖：数据模型、编辑体验、页面路由、ES/OpenSearch 索引、检索聚合、相关推荐、API、缓存与运维、迁移与测试清单。拿来即可集成。

---

# 0. 总体原则（信息架构）

* **Channel（频道）= 导航/栏目/版面**：树状结构、可运营（排序、布局、精选位）、承载 URL 与权限。
* **Tag（标签）= 内容特征**：数量多、跨栏目、用于聚合/推荐/搜索。
* **Article（文章）**：**主频道必选**（决定归属/URL/导航），**副频道可选**（跨露）；可打多个 Tag。

---

# 1. 数据模型（`news/models.py`）

## 1.1 本项目实现（保留 core.Channel）

> 说明：当前项目已存在 `core.Channel` 表并已部署 OpenSearch，故不引入 Wagtail 的 `ChannelPage` 树结构。
> 采用 Tag.md 的做法：`ArticlePage + ClusterTaggableManager(through=ArticlePageTag)`，并在 through 增加 `site` 维度，便于多站点过滤；频道仍由 `core.Channel` 管理。

```python
# news/models.py（关键片段）
from django.db import models
from wagtail.fields import RichTextField
from wagtail.models import Page, Site as WagtailSite
from modelcluster.fields import ParentalKey
from modelcluster.contrib.taggit import ClusterTaggableManager
from taggit.models import TaggedItemBase, Tag

class ArticlePageTag(TaggedItemBase):
    content_object = ParentalKey('ArticlePage', related_name='tagged_items', on_delete=models.CASCADE)
    site = models.ForeignKey(WagtailSite, on_delete=models.CASCADE, null=True, blank=True)

    class Meta:
        indexes = [models.Index(fields=['site'])]

class ArticlePage(Page):
    body = RichTextField(features=["h2","h3","bold","italic","link","ol","ul","hr","image"])
    summary = models.TextField(blank=True, default="")
    tags = ClusterTaggableManager(through=ArticlePageTag, blank=True, verbose_name="标签")

    # 与现有频道系统对接（核心：保留 core.Channel）
    primary_channel = models.ForeignKey('core.Channel', on_delete=models.PROTECT, related_name='primary_articles')
    # 可选：副频道（跨露）
    # secondary_channels = models.ManyToManyField('core.Channel', related_name='secondary_articles', blank=True)

    content_panels = Page.content_panels + [
        # 按需加入字段与 Panel
    ]
```

> ES 映射建议：新增 `primary_channel_slug/primary_channel_path/tags/site_id/first_published_at/url` 等字段；发布/撤销/删除钩子同步索引。

## 1.2 绿地实现（Wagtail ChannelPage，可选）

```python
# news/models.py
from django.db import models
from django.core.exceptions import ValidationError
from wagtail.fields import RichTextField
from wagtail.models import Page, Site as WagtailSite
from wagtail.snippets.models import register_snippet
from wagtail.contrib.routable_page.models import RoutablePageMixin, route
from wagtail.admin.panels import (
    FieldPanel, FieldRowPanel, PageChooserPanel, InlinePanel
)
from modelcluster.fields import ParentalKey
from modelcluster.models import ClusterableModel, Orderable
from modelcluster.contrib.taggit import ClusterTaggableManager
from taggit.models import TaggedItemBase, Tag

# —— Tag 扩展（可运营：颜色/描述/封面）——
@register_snippet
class NewsTag(Tag):
    color = models.CharField(max_length=16, blank=True, default="")
    desc  = models.TextField(blank=True, default="")
    cover = models.URLField(blank=True, default="")

    class Meta:
        verbose_name = "News Tag"
        verbose_name_plural = "News Tags"

# —— Channel 索引页：每个站点一个 —— 
class ChannelIndexPage(Page):
    intro = RichTextField(blank=True)
    subpage_types = ['news.ChannelPage']
    parent_page_types = ['wagtailcore.Page']

    def get_context(self, request, *args, **kwargs):
        ctx = super().get_context(request)
        ctx['channels'] = ChannelPage.objects.live().descendant_of(self).in_menu().order_by('sort_weight','title')
        return ctx

# —— Channel：可嵌套、可配置布局与排序 —— 
class ChannelPage(Page):
    nav_label   = models.CharField(max_length=64, blank=True)
    description = models.TextField(blank=True)
    hero_image  = models.URLField(blank=True)
    color       = models.CharField(max_length=16, blank=True)
    is_featured = models.BooleanField(default=False)
    sort_weight = models.IntegerField(default=100)
    layout = models.CharField(
        max_length=32,
        choices=[('default','Default'),('magazine','Magazine'),('timeline','Timeline')],
        default='default'
    )
    seo_keywords = models.CharField(max_length=256, blank=True)

    subpage_types = ['news.ChannelPage', 'news.ArticlePage']
    parent_page_types = ['news.ChannelIndexPage', 'news.ChannelPage']

    content_panels = Page.content_panels + [
        FieldPanel('nav_label'),
        FieldPanel('description'),
        FieldPanel('hero_image'),
        FieldRowPanel([FieldPanel('color'), FieldPanel('sort_weight')]),
        FieldRowPanel([FieldPanel('is_featured'), FieldPanel('layout')]),
        FieldPanel('seo_keywords'),
    ]

    class Meta:
        ordering = ["sort_weight", "title"]

    @property
    def display_name(self):
        return self.nav_label or self.title

    def get_articles_qs(self):
        # 本频道及子孙频道的文章时间流
        return ArticlePage.objects.live().public().descendant_of(self).order_by('-first_published_at')

# —— Article-Tag 中间表：可记录站点维度（可选）——
class ArticlePageTag(TaggedItemBase):
    content_object = ParentalKey('ArticlePage', related_name='tagged_items', on_delete=models.CASCADE)
    site = models.ForeignKey(WagtailSite, on_delete=models.CASCADE, null=True, blank=True)

    class Meta:
        indexes = [models.Index(fields=['site'])]

# —— Article：主频道必选，副频道可选，多 Tag —— 
class ArticlePage(Page):
    summary = models.TextField(blank=True, default="")
    body    = RichTextField(features=["h2","h3","bold","italic","link","ol","ul","hr","image"])
    hero    = models.URLField(blank=True, default="")
    city    = models.CharField(max_length=64, blank=True, default="")

    # 主频道（唯一）
    primary_channel = models.ForeignKey(
        'news.ChannelPage',
        on_delete=models.PROTECT,
        related_name='primary_articles',
        verbose_name="主频道"
    )

    # 标签
    tags = ClusterTaggableManager(through=ArticlePageTag, blank=True, verbose_name="标签")

    parent_page_types = ['news.ChannelPage']  # 文章放在某个频道树下
    subpage_types = []

    content_panels = Page.content_panels + [
        FieldPanel('summary'),
        FieldPanel('body'),
        FieldPanel('hero'),
        FieldPanel('city'),
        PageChooserPanel('primary_channel', ['news.ChannelPage']),
        InlinePanel('secondary_channels', label="副频道（可选，多选）"),
        FieldPanel('tags'),
    ]

    def clean(self):
        super().clean()
        if not self.primary_channel_id:
            raise ValidationError({"primary_channel": "文章必须选择一个主频道。"})

class ArticleSecondaryChannel(Orderable):
    page = ParentalKey(ArticlePage, related_name='secondary_channels', on_delete=models.CASCADE)
    channel = models.ForeignKey('news.ChannelPage', on_delete=models.PROTECT, related_name='+')
```

---

# 2. 页面路由与聚合

## 2.0 原则（结合 Tag.md）
- 频道页：仍通过 `core.Channel` 驱动（导航/排序/布局在运营端维护）。
- 标签页：提供 TagHub（/tags 与 /tags/<slug>），用于横向聚合与 SEO 入口。
- 聚合：频道流/标签流统一走 OpenSearch 查询；“今日头条/热榜”由后端预计算+缓存提供。

## 2.1 Tag Hub（列表 + 聚合页，`/tags/` 与 `/tags/<slug>/`）

```python
# news/models.py（续）
class TagHubPage(RoutablePageMixin, Page):
    subpage_types = []

    @route(r"^$")
    def list_tags(self, request):
        from django.core.paginator import Paginator
        qs = NewsTag.objects.all().order_by('name')
        page = request.GET.get("page", 1)
        return self.render(request, context={"tags": Paginator(qs, 60).get_page(page)})

    @route(r"^([\w-]+)/$")
    def by_tag(self, request, tag_slug):
        from django.shortcuts import get_object_or_404
        tag = get_object_or_404(NewsTag, slug=tag_slug)
        current_site = WagtailSite.find_for_request(request)
        articles = ArticlePage.objects.live().public().filter(
            tagged_items__tag__slug=tag.slug
        ).distinct().order_by('-first_published_at')
        # 若需站点隔离：加 .filter(tagged_items__site=current_site)
        return self.render(request, context={"tag": tag, "articles": articles})
```

## 2.2 频道页（`ChannelPage`）

* 直接用 `get_articles_qs()` 渲染“本频道+子孙”的时间流。
* 可按 `layout` 选择不同模板局部（default/magazine/timeline）。

---

# 3. OpenSearch/Elasticsearch 集成

## 3.1 安装与配置

```bash
pip install opensearch-py   # 或 elasticsearch==7.x
```

```python
# settings.py 片段
OPENSEARCH = {
    "HOSTS": ["http://localhost:9200"],
    "INDEX_ARTICLE": "news_articles_v1",
}
```

## 3.2 索引映射（含频道与标签维度）

```python
# search/indexes.py
from opensearchpy import OpenSearch
from django.conf import settings

def get_client():
    return OpenSearch(hosts=settings.OPENSEARCH["HOSTS"])

ARTICLE_MAPPING = {
    "mappings": {
        "properties": {
            "id": {"type":"keyword"},
            "title": {"type":"text","fields":{"raw":{"type":"keyword"}}},
            "summary": {"type":"text"},
            "body": {"type":"text"},
            "site_id": {"type":"keyword"},
            "site_hostname": {"type":"keyword"},
            "url": {"type":"keyword"},
            "first_published_at": {"type":"date"},
            "city": {"type":"keyword"},
            # 频道维度
            "primary_channel_id": {"type":"keyword"},
            "primary_channel_slug": {"type":"keyword"},
            "primary_channel_path": {"type":"keyword"},
            "secondary_channel_ids": {"type":"keyword"},
            "secondary_channel_slugs": {"type":"keyword"},
            # 标签维度
            "tags": {"type":"keyword"},
        }
    }
}

def ensure_article_index():
    client = get_client()
    index = settings.OPENSEARCH["INDEX_ARTICLE"]
    if not client.indices.exists(index=index):
        client.indices.create(index=index, body=ARTICLE_MAPPING)
```

## 3.3 序列化与写入

```python
# search/serializers.py
from wagtail.models import Site as WagtailSite
from news.models import ChannelPage

def _channel_path(channel: ChannelPage):
    # 例：["channels", "news", "politics"] -> 可按你站点树定义裁剪
    ancestors = channel.get_ancestors().type(ChannelPage).specific()
    names = [a.slug for a in ancestors] + [channel.slug]
    return names

def article_to_doc(page, request=None):
    site = page.get_site()
    primary = page.primary_channel.specific if page.primary_channel_id else None

    return {
        "id": str(page.id),
        "title": page.title,
        "summary": page.summary,
        "body": page.body.source if hasattr(page.body, "source") else page.body,
        "site_id": str(site.id) if site else "",
        "site_hostname": site.hostname if site else "",
        "url": page.url,
        "first_published_at": (page.first_published_at or page.latest_revision_created_at),
        "city": page.city or "",
        # 频道
        "primary_channel_id": str(primary.id) if primary else "",
        "primary_channel_slug": primary.slug if primary else "",
        "primary_channel_path": _channel_path(primary) if primary else [],
        "secondary_channel_ids": [str(sc.channel_id) for sc in page.secondary_channels.all()],
        "secondary_channel_slugs": [sc.channel.slug for sc in page.secondary_channels.select_related('channel')],
        # 标签
        "tags": list(page.tags.values_list("name", flat=True)),
    }
```

```python
# search/indexer.py
from django.conf import settings
from .indexes import get_client
from .serializers import article_to_doc

def index_article(page, request=None):
    client = get_client()
    index = settings.OPENSEARCH["INDEX_ARTICLE"]
    doc = article_to_doc(page, request=request)
    client.index(index=index, id=doc["id"], body=doc, refresh="false")

def delete_article(page_id):
    client = get_client()
    index = settings.OPENSEARCH["INDEX_ARTICLE"]
    client.delete(index=index, id=str(page_id), ignore=[404], refresh="false")
```

## 3.4 发布钩子（自动同步）

```python
# news/wagtail_hooks.py
from wagtail import hooks
from django.dispatch import receiver
from wagtail.signals import page_published, page_unpublished, page_deleted
from .models import ArticlePage, ArticlePageTag
from search.indexer import index_article, delete_article
from wagtail.models import Site as WagtailSite

@receiver(page_published)
def on_page_published(sender, **kwargs):
    page = kwargs.get("page")
    request = kwargs.get("request")
    if isinstance(page, ArticlePage):
        # 可写入站点到 ArticlePageTag（便于站点维度过滤）
        current_site = WagtailSite.find_for_request(request) if request else page.get_site()
        ArticlePageTag.objects.filter(content_object=page).update(site=current_site)
        index_article(page, request=request)

@receiver(page_unpublished)
def on_page_unpublished(sender, **kwargs):
    page = kwargs.get("page")
    if isinstance(page, ArticlePage):
        delete_article(page.id)

@receiver(page_deleted)
def on_page_deleted(sender, **kwargs):
    instance = kwargs.get("instance")
    if isinstance(instance, ArticlePage):
        delete_article(instance.id)
```

---

# 4. 检索/聚合/相关推荐（`search/queries.py`）

```python
from django.conf import settings
from .indexes import get_client

def search_articles_by_channel_slug(slug, include_descendants=True, site_id=None, size=20, from_=0):
    must = []
    if include_descendants:
        must.append({"terms": {"primary_channel_path": [slug]}})
    else:
        must.append({"term": {"primary_channel_slug": slug}})
    if site_id:
        must.append({"term": {"site_id": str(site_id)}})
    body = {
        "query": {"bool": {"must": must}},
        "sort": [{"first_published_at": {"order":"desc"}}],
        "from": from_, "size": size
    }
    return get_client().search(index=settings.OPENSEARCH["INDEX_ARTICLE"], body=body)

def search_articles_by_tag(tag_name, site_id=None, size=20, from_=0):
    must = [{"term": {"tags": tag_name}}]
    if site_id:
        must.append({"term": {"site_id": str(site_id)}})
    body = {
        "query": {"bool": {"must": must}},
        "sort": [{"first_published_at": {"order":"desc"}}],
        "from": from_, "size": size
    }
    return get_client().search(index=settings.OPENSEARCH["INDEX_ARTICLE"], body=body)

def top_tags(site_id=None, size=30):
    must = []
    if site_id:
        must.append({"term": {"site_id": str(site_id)}})
    body = {
        "size": 0,
        "query": {"bool": {"must": must}} if must else {"match_all": {}},
        "aggs": {"top_tags":{"terms":{"field":"tags","size":size}}}
    }
    res = get_client().search(index=settings.OPENSEARCH["INDEX_ARTICLE"], body=body)
    return res["aggregations"]["top_tags"]["buckets"]

def related_by_tags(page, limit=8):
    tags = list(page.tags.values_list("name", flat=True))
    if not tags:
        return []
    body = {
        "query": {
            "bool": {
                "must": [{"terms":{"tags": tags}}],
                "must_not": [{"term":{"id": str(page.id)}}]
            }
        },
        "size": limit
    }
    res = get_client().search(index=settings.OPENSEARCH["INDEX_ARTICLE"], body=body)
    return [h["_source"] for h in res["hits"]["hits"]]
```

---

# 5. API（用于前端/Portal 聚合）

```python
# news/api.py
from django.http import JsonResponse, Http404
from wagtail.models import Site as WagtailSite
from .models import ChannelIndexPage, ChannelPage, ArticlePage
from search.queries import search_articles_by_channel_slug, search_articles_by_tag, top_tags

def api_channels(request):
    site = WagtailSite.find_for_request(request)
    index = ChannelIndexPage.objects.child_of(site.root_page).live().first() if site else None
    if not index:
        return JsonResponse({"channels": []})
    channels = ChannelPage.objects.child_of(index).live().in_menu().order_by('sort_weight')
    data = [{"id": c.id, "title": c.title, "slug": c.slug, "url": c.url, "layout": c.layout} for c in channels]
    return JsonResponse({"channels": data})

def api_channel_articles(request, slug):
    site = WagtailSite.find_for_request(request)
    res = search_articles_by_channel_slug(slug, include_descendants=True, site_id=site.id if site else None, size=int(request.GET.get("size", 20)))
    return JsonResponse({"hits": [h["_source"] for h in res["hits"]["hits"]]})

def api_top_tags(request):
    site = WagtailSite.find_for_request(request)
    buckets = top_tags(site_id=site.id if site else None, size=int(request.GET.get("size", 30)))
    return JsonResponse({"tags": buckets})

def api_tag_articles(request, tag_slug):
    from taggit.models import Tag
    from django.shortcuts import get_object_or_404
    tag = get_object_or_404(Tag, slug=tag_slug)
    site = WagtailSite.find_for_request(request)
    res = search_articles_by_tag(tag.name, site_id=site.id if site else None, size=int(request.GET.get("size", 20)))
    return JsonResponse({"hits": [h["_source"] for h in res["hits"]["hits"]]})
```

```python
# news/urls.py
from django.urls import path
from .api import api_channels, api_channel_articles, api_top_tags, api_tag_articles

urlpatterns = [
    path("api/channels/", api_channels, name="api_channels"),
    path("api/channels/<slug:slug>/", api_channel_articles, name="api_channel_articles"),
    path("api/tags/top/", api_top_tags, name="api_top_tags"),
    path("api/tags/<slug:tag_slug>/", api_tag_articles, name="api_tag_articles"),
]
```

---

# 6. 模板与 SEO 要点（简述）

* **频道页**：标题/描述/封面、时间流列表；支持分页；侧栏显示热门标签与本频道子频道。
* **标签页**：`/tags/<slug>/` 唯一 URL，`<title>` 包含标签名与分页；可加 “更多此标签的站点/频道”。
* **Sitemap**：纳入 `ChannelIndexPage`、各 `ChannelPage`、热门标签（设定文档数阈值）。
* **Canonical**：跨站复用标签时，Portal 作为 canonical（可选运营策略）。

---

# 7. 缓存与性能

* **页面缓存**：频道页、标签页使用片段缓存（60–120s）；文章发布后短 TTL 失效。
* **ES 结果缓存**：热门标签（聚合）与频道流查询结果 30–120s 缓存。
* **DB 优化**：

  * `ArticlePage` 列表 `select_related('primary_channel')`，`prefetch_related('secondary_channels__channel','tagged_items')`
  * `ArticlePageTag(site)` 加索引（上文已加）；`ChannelPage(sort_weight)` 加索引或用默认排序。

---

# 8. 运维与数据治理

## 8.1 首次/回填索引

```python
# news/management/commands/reindex_articles.py
from django.core.management.base import BaseCommand
from news.models import ArticlePage
from search.indexes import ensure_article_index
from search.indexer import index_article

class Command(BaseCommand):
    help = "Reindex all live ArticlePage to OpenSearch"

    def handle(self, *args, **options):
        ensure_article_index()
        qs = ArticlePage.objects.live().public()
        for p in qs.iterator(chunk_size=200):
            index_article(p)
        self.stdout.write(self.style.SUCCESS(f"Indexed {qs.count()} articles."))
```

## 8.2 标签合并（脏数据治理）

```python
# news/management/commands/merge_tags.py
from django.core.management.base import BaseCommand
from taggit.models import Tag

class Command(BaseCommand):
    help = "Merge tag B into tag A. Usage: --src 'A' --dst 'B' (keep B, replace A->B)"

    def add_arguments(self, parser):
        parser.add_argument("--src", required=True)
        parser.add_argument("--dst", required=True)

    def handle(self, *args, **opts):
        src = Tag.objects.get(name=opts["src"])
        dst = Tag.objects.get(name=opts["dst"])
        for item in src.taggit_taggeditem_items.all():
            item.tag = dst
            item.save(update_fields=["tag"])
        src.delete()
        self.stdout.write(self.style.SUCCESS(f"Merged '{opts['src']}' -> '{opts['dst']}'"))
```

---

# 9. 迁移与落地步骤

1. **创建页面类型**：每个站点根下创建 `ChannelIndexPage`，在其下建立顶级频道树（要闻/国际/财经/科技/文体等），`in_menu=True` 控制导航显示顺序，`sort_weight` 控序。
2. **调整文章模型**：确保 `ArticlePage` 有 `primary_channel`（必选）与 `secondary_channels`、`tags`。
3. **发布钩子**：启用 `wagtail_hooks.py` 自动索引；新增/撤销/删除自动同步 ES。
4. **模板接入**：频道页渲染时间流与精选位；标签页渲染聚合；首页读取 `is_featured` 频道位。
5. **API 与前端**：接入 `news/urls.py`，前端（React/Next）调用接口或直连 ES。
6. **初始化索引**：运行 `python manage.py reindex_articles`。
7. **运维治理**：定期用 `merge_tags` 清洗同义/错别字标签；建议限制每篇文章标签数（如 ≤10）。

---

# 10. 测试清单（最小可用）

* 频道树创建（含二级/三级），导航渲染顺序正确。
* 文章发布：主频道必选校验通过；副频道/标签保存正常。
* `/channels/`、频道页、`/tags/`、`/tags/<slug>/` 可访问并分页。
* API：`/api/channels/`、`/api/channels/<slug>/`、`/api/tags/top/`、`/api/tags/<slug>/` 返回正确。
* 新发布/撤销/删除文章 → ES 文档同步增删。
* 多站点切换 Hostname 验证站点过滤逻辑。
* 热门标签/频道流结果缓存命中率与延迟达标。

---

## 结论

* **Channel = Page（树）**：承担导航、URL、权限、运营与 SEO；**主频道必选**，副频道用于跨露。
* **Tag = 特征维度**：用于聚合、搜索与推荐；与频道分工明确、互补。
* **Article = 内容主体**：多 Tag + 主/副频道，自动索引到 ES，支撑门户与多站点聚合。

如需要，我可以把以上代码**按你的项目目录结构**（apps 分层、`INSTALLED_APPS`、`urls.py` 汇总、Docker Compose 中的 OpenSearch、Nginx 路由）整理成**可运行的最小样例仓库骨架**（含基础模板与前端调用示例）。

---

# 附录A：实施细则（生产就绪）

## A.1 OpenSearch 索引设置（settings + 别名 + 零停机重建）

```json
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 1,
    "refresh_interval": "1s",
    "index": {
      "codec": "best_compression"
    },
    "analysis": {
      "analyzer": {
        "zh_smart": { "tokenizer": "smartcn_tokenizer" },
        "ik_smart": { "tokenizer": "ik_smart" }
      }
    }
  }
}
```

- 使用别名（alias）管理：`news_articles_current -> news_articles_v1`，重建到 v2 后切换别名，零停机。
- 映射中的 `title/summary/body` 可选用 `ik_smart` 或 `smartcn` 分词，保留 `raw` 关键词字段做排序与精确聚合。

## A.2 深分页策略（search_after 示例）

```json
{
  "sort": [
    {"first_published_at": {"order": "desc"}},
    {"id": {"order": "desc"}}
  ],
  "size": 20,
  "search_after": ["2025-09-10T12:00:00Z", "123456"]
}
```

- 返回页携带上一条的 `[first_published_at, id]` 作为下一次 `search_after` 的游标，避免大 offset 性能问题。

## A.3 缓存与失效（Redis + Surrogate-Key）

- Redis Key 规范：`agg:headlines:{site}`、`agg:hot:{site}`，TTL 60–120s。
- 失效触发：文章发布/撤销/删除时，按站点与频道/标签相关维度清理相关 Key（或标记为 stale）。
- HTTP 缓存响应头：`Cache-Control: public, s-maxage=60, stale-while-revalidate=300`；自定义 `Surrogate-Key: site:{site} channel:{slug} tag:{name}`。

## A.4 一致性与补偿

- 发布钩子失败重试：Celery 重试（指数退避、最大重试次数），失败入死信队列（DLQ）。
- 定时对账任务：扫描最近 N 分钟发布的文章，校验索引缺失并补写。
- 读路径降级：缓存缺失→读 ES；ES 异常→读 DB（短路保护，记录告警）。

## A.5 标签治理与规范

- 约束：每篇文章标签数 ≤ 10；黑名单标签拒绝保存；保留字校验。
- 工具：`merge_tags` 合并命令；支持别名表（synonyms），写入时归一；后台提供合并/禁用操作。

## A.6 观测与 SLO

- 指标：
  - 缓存命中率（headlines/hot）> 90%
  - ES 查询 P95 < 200ms；聚合 API P95 < 100ms
  - Celery 任务成功率 > 99%，滞留队列长度告警
  - 错误率阈值与报警（API 5xx、索引失败、缓存穿透）
- 仪表板：Grafana/ELK，按站点与模块维度查看。

## A.7 安全与配额

- 公共 API 节流：IP/User/Session 三级限流（如 60 req/min），带滑窗与白名单。
- 管理端审计：标签合并/删除、索引重建的操作日志与权限分级。
- 防击穿/穿透：热点 Key 预热、Bloom 过滤、随机 TTL。

## A.8 上线与回滚

- 灰度：前端从 Next 聚合 API 切换到 Django 聚合 API 可配置开关（按站点/流量百分比）。
- 回滚：保留 Next 聚合实现与 ES/缓存的兼容层；遇故障快速回切；别名回滚上一个索引版本。

