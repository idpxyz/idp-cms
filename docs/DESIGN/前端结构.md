你的“混合方案”方向是对的，而且这份目录与职责划分基本合理。下面我把它**评估 + 微调成可直接落地的版本**，重点解决性能、缓存、可观测性与越权风险。

# 结论

* **保留**：Django 作为“核心数据 API”；Next.js 仅放“前端特定 API + 必要代理/BFF”。
* **微调**：把 Next.js 下的 proxy 路由定位为**薄层**（签名、拼装、脱敏、降级），避免变成第二套后端；并在命名、缓存、超时/熔断、鉴权上加硬约束。

---

# 推荐目录（你给的结构 + 小幅规范化）

```
sites/
├── app/
│   ├── (portal)/
│   ├── (localsite)/
│   └── api/
│       ├── proxy/                # 仅转发/拼装的小胶水（BFF）
│       │   ├── site-settings/route.ts
│       │   ├── articles/route.ts
│       │   └── cache/route.ts    # 触发 revalidateTag/Path
│       ├── frontend/             # 纯前端专属能力（无后端依赖）
│       │   ├── layout/route.ts
│       │   ├── theme/route.ts
│       │   └── modules/route.ts
│       └── internal/             # 仅 Portal/Localsite 内部使用
│           └── preview/route.ts  # 预览、OG、RSS等
├── themes/
├── layouts/
└── components/
```

---

# 关键改良点（务必落实）

## 1) 路由命名与边界

* **后端 Django**：`/cms/api/v1/*`（建议用同域反代前缀 `/cms`，避免与 Next 自己的 `/api` 冲突）。
* **Next.js**：

  * `/api/proxy/*`：只做代理/拼装/签名（**不得**承载核心业务规则；请求必须服务端发起）。
  * `/api/frontend/*`：仅前端态（布局/主题/模块配置），**不触达数据库**。
  * `/api/internal/*`：预览/OG/RSS 等，仅服务端与编辑后台调用。
* **页面取数优先级**：直连 `/cms/api/v1/*` > `/api/proxy/*`（仅当确需拼装/签名时）。

## 2) 运行时与性能

* **proxy 路由**统一指定 **Node.js runtime**（不是 Edge），以便使用 Node 库与稳定的 `fetch` 语义；对“轻量签名/小 JSON 拼装”可单独用 Edge。
* `fetch` 统一带：

  * `{ next: { revalidate: 120, tags: ['site:HOST', ...] } }`
  * 上游（Django）响应头务必包含 `Cache-Control/ETag/Surrogate-Key`，以命中边缘缓存。
* **超时与重试**：proxy 里对上游设置 `timeout=2~5s`、指数退避重试（≤2 次），并有**快速失败**与**兜底空状态**。

## 3) 安全与越权

* `/api/proxy/*` 必须校验 `site` 合法且在**白名单**（防止开放代理）。
* 对需要签名的上游请求，**签名逻辑只能在 proxy**；严禁把密钥下发到浏览器。
* 对 webhook/revalidate：HMAC + 时间窗（±5min）+ 幂等 `nonce`（Redis/kv）。

## 4) 观测与故障定位

* 统一 `x-request-id` 贯穿：浏览器 → Next → Django；
* 记录 `upstream_status`, `upstream_time`, `cache_status`, `tags`；
* proxy 返回错误时**透传上游状态码**并加 `upstream` 字段，便于排障。

## 5) 缓存协同（CDN/ISR/Proxy）

* **上游（Django）**：`Cache-Control: public, s-maxage=120, stale-while-revalidate=60` + `ETag` + `Surrogate-Key: site:..., page:..., channel:..., region:...`。
* **Next 页面/接口**：对齐 `revalidate=120`，所有返回打同样的 tag；
* **Webhook**：仅触发 `revalidateTag/Path`（不要在 webhook 里直接清 CDN，除非失败重试策略完善）。

---

# 示例：`/api/proxy/articles/route.ts`

```ts
import { NextRequest, NextResponse } from 'next/server'

export const runtime = 'nodejs'      // 避免 edge 限制
export const revalidate = 120

const CMS = process.env.CMS_ORIGIN   // e.g. https://cms.aivoya.com

export async function GET(req: NextRequest) {
  const url = new URL(req.url)
  const site = url.searchParams.get('site') || ''
  if (!isAllowedSite(site)) {
    return NextResponse.json({ error: 'invalid site' }, { status: 400 })
  }

  const upstream = new URL('/api/v1/articles', CMS)
  url.searchParams.forEach((v, k) => upstream.searchParams.set(k, v))

  const res = await fetch(upstream.toString(), {
    // 2~5s 可调；失败可做至多2次轻重试
    // @ts-ignore
    signal: AbortSignal.timeout(4000),
    headers: { 'x-request-id': req.headers.get('x-request-id') || crypto.randomUUID() },
    // 让 Next/边缘参与缓存
    next: { revalidate: 120, tags: [`site:${site}`] }
  })

  // 透传状态码与关键响应头（命中 CDN/ISR）
  const body = await res.text()
  const out = new NextResponse(body, { status: res.status })
  ;['cache-control','etag','surrogate-key','content-type'].forEach(h => {
    const v = res.headers.get(h); if (v) out.headers.set(h, v)
  })
  return out
}

function isAllowedSite(host: string) {
  return !!host && /^[a-z0-9.-]+$/.test(host) && !host.includes('..')
}
```

---

# 示例：页面取数“优先直连后端”

```ts
// lib/api.ts
export async function getArticles(host: string, params: Record<string, any> = {}) {
  const base = process.env.NEXT_PUBLIC_API_BASE || '/cms/api/v1' // 同源反代优先
  const url = new URL(`${base}/articles`, location.origin)       // '/cms/api/v1/articles'
  url.searchParams.set('site', host)
  for (const [k,v] of Object.entries(params)) url.searchParams.set(k, String(v))
  const res = await fetch(url, { next: { revalidate: 120, tags: [`site:${host}`] } })
  if (!res.ok) throw new Error(`Upstream ${res.status}`)
  return res.json()
}
```

> 只有当需要“多接口拼装/签名/脱敏”时，页面才改打 `/api/proxy/*`。

---

# 何时用 proxy、何时直连（落地准则）

* **直连 `/cms/api/v1/*`**：普通列表/详情、频道页、站点设置（90%+ 请求）。
* **走 `/api/proxy/*`**：

  1. 需要**拼装**多接口为一个 payload；
  2. 需要**服务端签名/脱敏/灰度开关**；
  3. 需要**合并缓存策略**（不同 TTL/tag 的资源整合后统一缓存）。

---

## 一句话建议

你的“混合方案”已经对了；照上面的**硬约束 + 运行时 + 缓存/安全/观测**再收一收，就能在保证性能与安全的前提下，让前端开发者在 `sites` 项目里“一站式”完成工作，同时保留 Django 作为稳定的核心 API。
